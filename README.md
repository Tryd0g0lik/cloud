D работе 

[frontend](https://github.com/Tryd0g0lik/cloud_frontend)

# CLOUD_USER
1. Настраивая файл `settings.py` меняем базовую модель `User` на `UserRegister`. \
`UserRegister` наследуется от `User`.

- пользователь регистрируется через '`cloud_user/views.py`';
- администратор через '`cloud/views.py`'.

Пользователь и администратор по сценарию из '`cloud_user/views.py`':
- '`login`' и '`logout`'; 
- редактировать данные личного профиля;
- переименовать файл;
- поделиться ссылкой;
- генератор '`csrftoken`' '`{{baseUrl}}/users/`'. Сценарий для \
сравнения токена '`project.__init__.py::Csrft`':

Пользователь и администратор по сценарию из '`cloud_file/views.py`':
- получить данные файла '`{{baseUrl}}/files/:pk/`'. \
'`:pk`' владелец файла;
- получить список файлов '`{{baseUrl}}/files/`';
- создать ссылку для скачивания '`{{baseUrl}}/files/:pk/referral_links/`'. \
'`:pk`' владелец файла;
- скачиваем файл '`{{baseUrl}}/files/:pk/download/`' \
'`:pk`' ключ файла. Тип строка. Пример '`35eb6497-7293-488b-92d0-25681ecee224`';
- удалить один файл '`{{baseUrl}}/files/:pk/remove/`';
- удалить все файлы '`{{baseUrl}}/files/:pk/remove/`'. \
'`:pk`' владелец файла;
- переименовать файл '`{{baseUrl}}/files/:pk/rename/`'. \
'`:pk`' владелец файла;
- изменить/добавить комментарий к файлу '`{{baseUrl}}/files/:pk/update_comment/`'. 

Администратор по сценарию из '`cloud/views.py`':
 - регистрация администратора сайта '`{{baseUrl}}/admins/choice/`' 
 - получает список всех пользователей и фалов '`{{baseUrl}}/files/`'
 - получает данные одного пользователя и его файлов.'`{{baseUrl}}/files/:pk/`'\
'`:pk`' пользователя для которого получаем данные.
 - получается списоу и интерфейс файлов '``/admins/to/profile/:pk/``' \
'`:pk`' пользователя данные которого получаем. 
 -  - получается списоу и интерфейс профиля (ЛК) '`/admins/to/profile/files/:pk/`' \
'`:pk`' пользователя данные которого получаем. 

**Note:** '`{{baseUrl}}`' включает в себя '`http://127.0.0.1:8000/api/v1`'

## Аутентификация

- при [регистрации пользователь](#регистрация) получает реферальную ссылку на почту.
- в [cookie заложен](#cookie) ключ '`user_session`' (в браузере) и '`user_session_<id_usr>`' в db.
- в методах скрипты распределены для '`request.user.is_anthentificate`', \
'`not request.user.is_anthentificate`', '`request.user.is_staff`',

## Регистрация
1. Почта указанная при регистрации не изменяется.
2. При регистрации, на почту пользователя отправляется ссылка для \
подтверждения.

Ссылка для:
- пользователя - '`/api/v1/user/activate`';
- администратора - '`/api/v1/admins/activate`'.
Данная ссылка дополнительно содержит подпись/шифр по которой определяется - \
кто затребовал подтверждение email.

После клика по ссылке (на стороне почты пользователя) \
запускается сценарий из '`**/contribute/controler_activate.py`'.

### Note
- на подтексты (из '`url.pathname`'):'`user`', '`admins`' ориентируется сценарий  \
в файле '`controler_activate.py`';
- регистрация количества администраторов не ограничена. Для ограничения\
 количества возможно создать декоратор и укрыть метод '`AdminView.create`'.

### Проходит проверку. 
(ВРЕМЯ ЖИЗНИ ССЛЫКИ добавить).
Редирект:
- на страницу `URL_REDIRECT_IF_NOTGET_AUTHENTICATION` см `.env`;
- на страницу `URL_REDIRECT_IF_GET_AUTHENTICATION`.

### Password !!!
В django поступает 1 пароль из фронта. \
На фронте - пароль проходит через базовую проверку:
- пароль1 == пароль2.
- длина пароля.

От клиента на сервер, пароль уходит без хеша в синтаксисе (можно зашифровать).\
Для хеша своя маска используется.

Проверка на сервере.\ 
`cloud_user/views.py::UserView.create` `hash_password`  

Далее редирект на страницу `URL_REDIRECT_IF_GET_AUTHENTICATION` (данные из '`dotenv_.py`'.\
Если всё удачно пользователь возвращается на страницу с открытым профилем.\
Дополнительно сохраняем [данные в COOKIE](#cookie) (большая часть в базовом виде. Можно зашифровать)

## Email-message
`app.py` К сервису подачи сигнала (сигнал подаем когда требуется отправить \
сообщение на почту для аутентификации пользователя) подключаем \
`send_activation_notificcation` функцию отправления сообщения на почту.

Из текста `activation_letter_subject.txt` (А) создаем шаблон письма для предложения \
аутентификации и `email/activation_letter_body.txt` шаблон подтверждения \
аутентификации.


Сообщение (письмо) А имеет ссылку с подписью из `Signer` \
(из `send_activation_notificcation`). \
В '`controler_activate.py::user_activate`' - проверка подписи ('`sign`' - ниже). \
Сама функция срабатывает после клике по ссылке из письма юзера.

### Note
Письмо отправляется на первый хост из списка '`ALLOWED_HOSTS`' ('`settings.py`')  

- '`activation_letter_body.txt`' шаблон для пользователя;
- '`activation_admin_letter_body.txt`' шаблон для администратора;

## Signal (Сигнал) - 'sign' 
Когда создаём сигнал (`cloud_user/contribute/utilites.py` ), к параметру \
`sign` присваеваем значение. 

В данном случаем значением является `first_name` из модели \
подели `UserRegister`. \
Далее `first_name`  используем в:
- письмах;
- `cloud_user/contribute`;
- подпись `Signer` (`utilites.py`,`controler_activate.py`).

## Сообщение аутентификации

Запускаем метод `email_user`, из базовой модели пользователя, отправляет\
сообщение используя [send_mail](https://docs.djangoproject.com/en/5.1/topics/email/).

smtp сервер настроить ДЛЯ ПОЧТЫ. !!!!!

Сейчас сообщения приходят в консоль согласно настройке `settings.EMAIL_BACKEND`.


Изменить URL_REDIRECT_IF_GET_AUTHENTICATION для 301 кода

## Login
[Два варианта авторизации](#coookie-авторизация-на-сайте).\

Через метод `PATCH`, переменная `is_active` (из `requestBody`) имеет \
значение `True`. \
API: `api/v1/users/patch/<int:pk>/` \
<strike>при повторной активации пользователя на сайте, на почту пользователя</strike> \
<strike>поступает код и ссылка.</strike> \
<strike>нажимаем на ссылку, открывается страница с формой для кода.</strike>

<strike>Вводим код и проверка.</strike> 


Сам сигнал, для отправки сообщения отправляем через \
`views.py::send_message`.  
### Logout
Пользователь выходит из профиля.
Через метод `PATCH` отправляем на сервер. Переменная `is_active` (из `requestBody`) имеет \
значение `False`. 
API: `api/v1/users/patch/<int:pk>/`

### AnonymousUser 
При активации и деактивации пользователя, поступившие данные из клиента проходят проверку:
 - проверку hash-паролей;
 - проверку email (данная проверка имеет смысл, когда запрос к серверу\
отправляется при наличии 'index' в cookie клиента. Хотя... можно убрать\
`cloud_user/views.py::UserPatchViews.update_cell`);
 - затем `login(request, user)`.

## COOKIE
1. В БД `cacher` ключ `user_session` для cookie.
2. `user_session` - По сроку жизни ключа, требуем повторно авторизоваться \
на сайте - подтвердить присудствие владельца профиля.
3. В `cacher` по ключу `user_session` определим ID пользователя (вшит в имя ключа). 
Это хеш данные, синтаксис:   
```code
Это хеш данные, синтаксис:    'utf-8'
```text
<user_email>:<django_signer>
```
"[cloud_user/contribute/controler_activate.py](cloud_user/contribute/controler_activate.py)"
функция [create_signer(user)](cloud_user/contribute/sessions.py)\
Данные присваиваются переменной `user_session` и сохраняются базе данных `cacher`. \
`cacher` полученной из `settings.py::CACHES`.

`user_session` = время жизни 24 часа.\

Обновление записей в hash (cacher ), по умолчанию периодично в 30 минут. [Об этом ниже](#обновление-записей-в-hash)\
Удаление записей кеша (*"`user_session_< user_id >`"*) при выходе из профиля.

Как работаем с состоянием активации пользователя - смотреть `Активация` ([из описания фронтенда](https://gitverse.ru/Workaholic/cloud_frontend)).


### COOOKIE авторизация на сайте
Обычно из куки берем индекс, и данные "`user_session`". На сервере "`user_session`" 
сверяем. 

#### Вариант когда из прошлых посещений cookie сохранил данные
На сервер , синхронно отправляется 2 запроса.
1. Получаем токен.
2. Отправляем данные для авторизации.


#### Вариант когда cookie чистый    
1. Получаем токен.
2. Берем email из формы. Шифруем (*`ENCRYPT`*) и отправляем на сервер.\
На [сервера расшифровываем](cloud/services.py) и [получаем id пользователя](cloud/views.py) ("`api_get_index`").  
3. Отправляем данные для авторизации. Сравниваем хеш паролей.\
Тут "`user_session`" не имеем. Есть индекс, email и пароль.

**Note**: 
1. База данных имеет два вида хеша:
   - [x] для паролей;
   - [x] для ключа пользователя.
1. Кеш каждого вида/типа/категории (*не пользователя*) имеет свой шаблон маски.
1. Для сверки [csrf-токена используем](project/__init__.py) '`decorators_CSRFToken`' 

**Note**:
1. Для [обновления ключа пользователя](#обновление-записей-в-cache--usersession--userid--true-or-false-), на сервере есть отдельный [поток для обновления ключа пользователя](cloud_user/tasks.py).
1. Отбор пользователй для обработки проходит только тех кто имеет статус - активный и от последнего времени логирования прошло 1 и более 1-ого дня.
1. Совершаея переход между страницами сревиса, cookie браузера обновляется. Вместе с ним обновляется и ключ пользователя.
1. Деактивация пользователя:
   - [x] пользователь сам выйдет из профиля (*`logout`*) 
   - [x] не будет совершать ни каких событий в течение суток - в базе данных обновляется статус (*`is_Active`= `False`*) при очередной загрузке страницы.
   - [x] ключ пользователя со стороны клиента не совпадает с ключом из БД. "`user_session`" удаляется при деактивации. 
1. Загружаясь (*спустя сутки*), браузер запрашивает из cookie статуc пользователя и получая `False`, попадаем на главную.


### Обновление записей в cache (user_session< user_Id > True or False)
[Эта задача](cloud_user/tasks.py) проверяет время жизни строки в хэше \
(это '`cacher`' из '`settings.py`'. В коде запрашиваем как '`cache`').

Из БД выбирает пользователей по определенному количеству. \
Min (от) '`quantity`' Max (до) '`number`' и проверяет время жизни (так перебираем всю ДБ).

Затем изменяет время жизни пользователя, где '`last_login`' (из модели '`UserRegister`') меньше, чем '`hash_live_time`'.\
Или вовсе удаляет если '`is_active`' (из модели '`UserRegister`') = '`False`'. Это \
контрольное удаление (мало ли).  
Выборка пользователей из базы данных проходит по диапазону из '`number`'.\

Запуск каждые 30 минут в параллельном потоке, на основную работу приложения не влияет.

#### Note
Переменные приведены, чтоб сказать - свойства можно регулировать из вне. \
В данный момент используются значения по умолчанию.

## FILES
- Все методы асинхронные.
- Модель `FileStorage` из `cloud_file/models.py`
- Каждый файл получает два маршрута для сохранения (при загрузке на сервер).
    - `card/` - временной хранилище. Файл проходит проверку на дублирование:\  
    - [x] файл просто переименовать - проверку не пройдет так как дубль;
    - [x] файл с изменением в содержимом/контенте - считается как новый файл.

    - `uploads/` - конечное хранилище файла.
#### Note

Проверка модулем `hashlib.md5`из `cloud/hashers.py::md5_chacker` \
(`cloud_file/views.py::FileStorageViewSet.compare_twoFiles`).  

Два разных пользователя загрузят один файл на сервер  
дублирования не будет. \
Проверка дублирования в границах коллекции одного пользователя.
    - маршрут имеет синтаксис
```code
<uploads>/<user_id>/<year_upload>/<month_upload>/<day_upload>/File_name.now
```

### Загрузка файла на сервер
`FileStorageViewSet.create`.\
- загрузка любого расширения.
- проверки и ограничения по весу файла - нет.
- тут же создаём ту самую специальную ссылку, модулем `uuid.uuid4`.


### Дополнительно
'`cloud_file/views.py::FileStorageViewSet.generate_link`' Выполняет задачу \
из ТЗ - создает URL для скачивания. В ТЗ нет условия , что при каждом \
обращении на сервер должна генерироваться новая ссылка. Тем самым условие выполнено.

- '`FileStorageViewSet.remove`' удалить один или все файлы.
- '`FileStorageViewSet.rename`' переименовать файл при условии , что такое имя не встречается (в границах одного расширения) в базе данных.
- '`FileStorageViewSet.update_comment`' обновление комментария к файлу.
- '`FileStorageViewSet.download`' скачиваем файл. Последняя дата скачивания обновляется в базе данных.
- '`FileStorageViewSet.referral_links`' создаем ссылку для скачивания файла.
- '`project/__init__.py::decorators_CSRFToken`' декоратор для работы с '`CSRFToken`' (with sync or async methods) 

## Интерфейс пользователя c файлами
- загрузка файла
- список файлов
- удалить файл
- переименовать файл
- обновить комментарий к файлу
- генерация специальной ссылки
- скачать файл по специальной ссылке.

## Интерфейс профиля пользователя
 - редактирование имени 

## Интерфейс администратора c файлами
 - [базовый интерфейс для личного профиле](#интерфейс-пользователя-c-файлами);
 - получение сводных данных по сервису в виде таблиц:
 - [x] количество файлов на сервере (сводная строка);
 - [x] количество пользователей на сервере (сводная строка);
 - [x] количество файлов скаченных. Данное количество не указывает - сколько раз скачивался файл (сводная строка);
 - [x] '`User ID`'  (сводная таблица);
 - [x] '`User Name`' - ссылка для переходя в профиль пользователя (сводная таблица);
 - [x] '`Quantity files of user`' - ссылка для переходя к файлам пользователя (сводная таблица).
 - [базовый интерфейс для файлов](#интерфейс-пользователя-c-файлами) из профиля пользователя;

#### Note
Загрузка файла в коллекцию пользователя, администратором не возможна.

Дополнительное описание есть в репозитории [frontend](https://github.com/Tryd0g0lik/cloud_frontend). 


## Logging
Код имеет логирование. Результат видно в косоли и файле 'log_putout.log
```log
[2025-02-09 14:24:42,767 767] check_log_file logs : 63 INFO - Лог-файл был обнулен, так как количество строк превысило 3000.
[2025-02-09 14:24:42,768 768] check_log_file logs : 63 INFO - Лог-файл был обнулен, так как количество строк превысило 3000.
[2025-02-09 15:24:17,985 985] trigger_reload autoreload : 266 INFO - E:\Netologe\diplom\backend\logs.py changed, reloading.
[2025-02-09 15:24:22,351 351] <module> utilites : 17 INFO - START
[2025-02-09 15:24:22,352 352] <module> utilites : 20 INFO - Received a signature
[2025-02-09 15:24:22,353 353] <module> apps : 28 INFO - START
[2025-02-09 15:24:22,354 354] <module> apps : 76 INFO - cloud_user.apps Signal WAS STARTED
[2025-02-09 15:24:23,095 95] run_with_reloader autoreload : 668 INFO - Watching for file changes with StatReloader
[2025-02-09 15:24:24,845 845] <module> sessions : 16 INFO - START
```



Фронт
Загрузка данных на страницу добавить проверку is_staff
На главную для админов выгрузить - количество и размер файлов, ссылка для перехода к интерфейсу управления этими файлами
Note:
- количество файлов вывести отдельно строкой
- интерфейс управления этими файлами?? Что он должен включать

в интерфейсе пользователя необходимо отображение списка файлов,
загруженных пользователем в хранилище, с основной информацией
о них: имя файла, комментарий, размер, дата загрузки, дата последнего скачивания

в интерфейсе необходимо  - список файлов, загруженных пользователем в хранилище,
с основной информацией о них: имя файла, комментарий, размер, дата загрузки,
дата последнего скачивания



- [x] регистрация пользователя — с валидацией входных данных на соответствие требованиям, описанным выше;
- [x] получение списка пользователей;
- [x] удаление пользователя только админу;
- [x] аутентификация пользователя;
- [x] выход пользователя из системы — logou


Для пользовтеля на работает комент и переименования файла
